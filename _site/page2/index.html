<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->

<head>
  <meta charset="utf-8">
  <title></title>
  <meta name="author" content="Alberto Fernández-Capel">

  
  <meta name="description" content="
  
  
  
    
  
    
  

  
    
      El programador políglota
    

    Cada vez que programadores que provienen de distintos entornos se junta...">
  

  <link href='http://fonts.googleapis.com/css?family=Oswald:400,300,700|Open+Sans' rel='stylesheet' type='text/css'>
  <link href="/stylesheets/comestible.css" media="screen, projection" rel="stylesheet" type="text/css">

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
  <script src="/javascripts/socialite.min.js"></script>
  <link href="" rel="alternate" title="" type="application/atom+xml">
</head>
<body>
  <div class="container">
    <header role="banner" id="main-header" class="row">
      <hgroup>
        <h1 id="blog-title" class="span3 offset1"><a href="//">Código Comestible</a></h1>
        <h2 id="blog-subtitle" class="span6">"La belleza será comestible o no será" <br/> - Salvador Dalí</h2>
      </hgroup>
    </header>

    <div class="row">
      <section id="main" class="span8">
        <div id="blog-index" class="row">
  
  
  
    <article class="entry" role="article">
  <div class="meta span1">
    <time class="date" datetime="" pubdate></time>
  </div>

  <div class="content span7">
    
      <h1 class="entry-title"><a href="/2010/07/02/programador-poliglota/">El programador políglota</a></h1>
    

    <p>Cada vez que programadores que provienen de distintos entornos se juntan para crear un nuevo proyecto surge la cuestión de qué lenguaje se va a utilizar, a la que suele seguir el inevitable flamewar sobre qué lenguaje es mejor. En seguida aparecen los viejos tópicos: java es lento, php sólo sirve para hacer aplicaciones sencillas, ruby no escala, erlang... ¿qué es eso de erlang?, etcétera.</p>

<p> Estas discusiones rara vez llegan a un resultado provechoso, y no sólo porque los argumentos utilizados muchas veces no tienen ningún fundamento, sino porque la pregunta -¿qué lenguaje es mejor?- está mal planteada: <strong>Los lenguajes no suelen ser mejores o peores por sí mismos, sino solamente más o menos adecuados para ciertas tareas</strong>.</p>

<p>Los lenguajes son herramientas. ¿Qué herramienta es mejor, un destornillador o una llave inglesa? Depende de si quieres atornillar un tornillo o enroscar una tuerca. Dice el proverbio chino: <em>al que tiene un martillo todo le parecen clavos</em>. Yo digo que antes de utilizar ese martillo para desenroscar una tuerca, el desarrollador debería plantearse si no habrá  alguna herramienta más adecuada para lo que quiere hacer.</p>

<p>Nos guste o no, la realidad de la web nos ha enfrentado con el hecho de que <strong>un sólo lenguaje ya no basta</strong>. Antiguamente era posible hacer una aplicación de escritorio completa usando sólo C, C++ o Java. En cambio, para hacer una aplicación web medianamente decente, hay que conocer el lenguaje en el que se programe el backend -ya sea ruby, php, java o c#-, pero además es inevitable tener conocimientos de SQL, javascript, css, html... Eso como mínimo. Repito: <strong>en el mundo web un sólo lenguaje ya no nos basta</strong>.</p>

<p>Y este punto no sólo se aplica a la diferencia entre el backend y el frontend de una aplicación web que, al fin y al cabo, son ámbitos distintos y por lo tanto parece natural que utilicemos lenguajes distintos. También dentro del servidor puede tener sus ventajas que utilicemos varios lenguajes de programación.</p>

<p>Los entornos de ejecución modernos, como la máquina virtual de Java o el CLR de .NET, hacen que los distintos lenguajes puedan convivir y entenderse entre ellos. Por ejemplo, la máquina virtual de Java puede ejecutar código escrito en Java, Ruby, Scala, Groovy, Clojure, Python, PHP, Javascript, Ada, Cobol, etcétera. <a href="http://en.wikipedia.org/wiki/List_of_JVM_languages">La lista es larga.</a> Y no sólo eso: yo puedo utilizar JRuby, por ejemplo, para llamar a código escrito en Java o en Scala desde mi programa escrito en Ruby.<strong> Gracias a la máquina virtual, las barreras entre lenguajes son cada vez más pequeñas</strong> y Ruby puede entenderse perfectamente con Java.</p>

<p>Un ejemplo claro es el <a href="http://www.grails.org/">framework web Grails</a>. Está pensado para utilizarse en Groovy, pero su núcleo está construido sobre Spring e Hibernate. Es decir, tenemos un framework web escrito en Groovy que se apoya en librerías escritas en Java. Y el resultado funciona muy bien.</p>

<p>En su libro <a href="http://oreilly.com/catalog/9780596519544"><em>The Productive Programmer</em></a>, <a href="http://www.nealford.com/">Neal Ford</a> llama a este enfoque <strong>programación políglota</strong>. ¿Qué es la programación políglota? Muy sencillo: se trata de utilizar en cada momento el lenguaje más adecuado para la tarea que haya que llevar a cabo. El programador políglota es aquel que tiene en su repertorio gran cantidad de herramientas -lenguajes-, conoce bien sus puntos fuertes y sus limitaciones, y sabe qué herramienta hay que utilizar para cada tarea.</p>

  </div>
</article>


  
  
    <article class="entry" role="article">
  <div class="meta span1">
    <time class="date" datetime="" pubdate></time>
  </div>

  <div class="content span7">
    
      <h1 class="entry-title"><a href="/2010/06/23/el-modelo-mcdonalds-y-el-modelo-google/">El modelo McDonalds y el modelo Google</a></h1>
    

    <p>En 1985 Michael Gerber escribió <a href="http://www.amazon.com/E-Myth-Revisited-Small-Businesses-About/dp/0887307280">el libro The E-Myth</a> donde explicaba el éxito de empresas como McDonald's o Burger King. McDonald's ha  creado una receta para montar negocio muy rentable, que es repetible por cualquiera, y la ha comercializado en forma de franquicia. McDonald's tiene éxito porque puedes ir a Torrelodones, a Münich o a Melbourne, pedir un Big Mac, <strong>y en los tres sitios obtendrás prácticamente el mismo producto</strong>.</p>

<p>Que un Big Mac sepa bien -o no, según el gusto- no depende de la pericia del cocinero. McDonald's ha conseguido destilar la receta del Big Mac en una serie de pasos exactos que no dan lugar a fallo: la carne se compra aquí, se hace durante tantos segundos y los ingredientes de la salsa son estos. Todo está especificado al milímetro para que el cocinero sólo tenga que seguir unos pasos sencillos para hacer un Big Mac. Si mañana el cocinero se va a trabajar a otro sitio, no es ningún problema porque es fácil encontrar a otro que haga exactamente el mismo trabajo. Y los Big Macs seguirán sabiendo igual. <strong>En McDonald's cualquiera es prescindible</strong>.</p>

<p>A gran parte del público no le gustan las sorpresas y ese el motivo de que McDonald's tenga tanto éxito: puede que la comida no sea gran cosa, pero cuando vas, <strong>sabes exactamente lo que te espera</strong>. No hay sorpresas.</p>

<p>Las franquicias suelen emplear este modelo de negocio: empaquetar un negocio que funciona y es reproducible y venderlo a cambio de una parte de los beneficios. Es un negocio rentable que ha permitido a empresas como McDonald's crecer hasta el infinito y más allá.</p>

<p>Pero lo que sirve para vender comida rápida no tiene por qué servir en otros campos como la informática. Pensemos, por ejemplo, en Google: Google no se dedica a contratar empleados para realizar un trabajo que podría hacer cualquiera, sino que hace justo lo contrario: contrata a gente muy especial, de la inmensa minoría más brillante y les encarga -o les permite crear- productos revolucionarios. <strong>Cualquiera no puede hacer un Gmail o un Google Maps</strong>, y si no fuera por el talento de gente como <a href="http://paulbuchheit.blogspot.com/">Paul Buchheit</a> -el creador de GMail- o los <a href="http://www.cnn.com/2009/TECH/10/27/rasmussen.brothers.google.wave/index.html">hermanos Rasmussen</a> -creadores de Google Maps y Google Wave- no existirían estos productos. <strong>El éxito de Google depende de que tenga trabajando en sus filas a las mentes más brillantes.</strong>.</p>

<p>Google y McDonald's son dos casos extremos, pero entre ellos hay un espectro continuo de empresas que valoran más o menos la iniciativa de sus empleados; más parecidas a Google o a McDonald's.</p>

<p>En España, por ejemplo, no es raro ver consultoras que se empeñan en aplicar el modelo McDonald's a la informática. Intentan crear un modelo de negocio basado en productos de baja calidad y en legiones de empleados, a los que pagan poco y forman menos, y que son completamente prescindibles. Dicen: <em>vamos a desarrollar este core para que después las vistas, o los módulos, los jsp o lo que sea, se puedan hacer en una software factory</em>. Es una manera de decir: vamos a hacer un producto que cualquiera pueda desarrollar, vamos a hacer que tus empleados sean prescindibles, vamos a inventar el BigMac-JSP.</p>

<p>Creo que en un campo como la informática, donde ser innovador es una ventaja enorme, esta estrategia tiene las patas muy cortas. Puede servir para crear productos chapuceros que funcionan si no eres demasiado exigente, pero nunca servirá para crear un producto de calidad. Así nunca se creará un producto memorable.</p>

  </div>
</article>


  
  
    <article class="entry" role="article">
  <div class="meta span1">
    <time class="date" datetime="" pubdate></time>
  </div>

  <div class="content span7">
    
      <h1 class="entry-title"><a href="/2010/06/10/que-es-la-deuda-tecnologica/">¿Qué es la deuda tecnológica?</a></h1>
    

    <p>¿Os habéis encontrado alguna vez con código mal escrito que es difícil de mantener y más difícil de reutilizar? Apuesto a que sí.</p>

<p>Ese código muchas veces no es chapucero porque el programador no sepa hacerlo mejor, sino porque se ha hecho con prisas y sin preocuparse en que ese código pueda extenderse con facilidad en el futuro. Se ahorra tiempo, por ejemplo, en técnicas como los test unitarios que mejoran considerablemente la calidad del código.</p>

<p>Cuando uno se ve forzado a trabajar con una base de código muy mal escrita, los proyectos acaban tardando mucho más de lo necesario. Lo que podíamos haber hecho en dos días acaba tardando diez. O cuarenta. Todo es mucho más complicado porque tenemos que enfrentarnos a las problemas que nos presenta el código legado.</p>

<p>Para explicar las consecuencias del código hecho con prisas <a href="http://c2.com/~ward/">Ward Cunningham</a> acuñó el término <strong>deuda tecnológica</strong>. Hacer código de mala calidad a toda prisa, es como pedir un crédito: puede que obtengamos un beneficio a corto plazo pero si tenemos que seguir desarrollando ese código, tarde o temprano tendremos que pagar todo el tiempo que nos habíamos ahorrado <strong>y los intereses</strong>. Refactorizar código mal escrito es siempre más difícil que escribirlo bien desde el principio.</p>

<p>A veces la deuda tecnológica tiene sentido. Puede que tengamos que terminar un producto antes que un competidor, o puede que si no terminamos pronto perdamos una gran oportunidad de negocio. En ese caso, la deuda tecnológica tiene el mismo sentido que la deuda financiera: incurrimos en algo de deuda para obtener unos beneficios tan grandes que compensan de sobra el pago de los intereses.</p>

<p>Sin embargo, la deuda tecnológica, como la financiera, también tiene un aspecto muy peligroso: recurrir a la deuda es una manera muy sencilla de tapar los problemas que tiene nuestro negocio. Entra dinero y crea la ilusión de que el negocio sigue funcionando, aunque en realidad sólo hemos aplazado los problemas al tiempo que los empeoramos.</p>

<p>Con la deuda tecnológica pasa lo mismo. Hacer constantemente chapuzas puede dar la sensación de que los proyectos avanzan. Sin embargo, al poco tiempo acabamos con una maraña de código inmantenible; lo que debería ser muy sencillo se convierte en complicado y los desarrollos avanzan cada vez más despacio.</p>

<p>Es porque todo nuestro esfuerzo se invierte en pagar los intereses de la deuda tecnológica.</p>

  </div>
</article>


  
  
    <article class="entry" role="article">
  <div class="meta span1">
    <time class="date" datetime="" pubdate></time>
  </div>

  <div class="content span7">
    
      <h1 class="entry-title"><a href="/2010/06/05/para-que-sirven-los-documentos-de-requisitos-funcionales/">Para qué sirven los documentos de requisitos funcionales</a></h1>
    

    <p>El sello que certifica que se está siguiendo el modelo en cascada es el documento de requisitos funcionales. El documento funcional especifica, antes que se empiece a programar, como debe ser el software y qué es lo que debe hacer. En teoría, el desarrollador puede consultarlo para aclarar cualquier duda que tenga sobre cómo funciona el software.</p>

<p>Digo en teoría, porque en la práctica esto no suele suceder. Yo mismo he tenido mi buena ración de documentos funcionales, me ha tocado escribirlos y corregirlos, pero nunca los he utilizado para lo que se supone que están hechos: para aclarar mis dudas sobre como debe funcionar un programa.</p>

<p>Los documentos funcionales no parecen muy útiles. Algunos expertos en hacer buen software, como la gente de 37 Signals, <a href="http://gettingreal.37signals.com/ch11_Theres_Nothing_Functional_about_a_Functional_Spec.php">incluso piensan que no sirven de nada</a>. Pero, entonces, ¿por qué seguimos haciendo documentos funcionales?</p>

<p>La respuesta, como casi siempre que se reincide en un error claro, no es tanto técnica como psicológica.</p>

<p>A muchos desarrolladores o responsables de proyectos<strong> les gustan los documentos de requisitos funcionales porque limitan su responsabilidad</strong>. Hacer buen software que contente al cliente es algo complicado; cumplir un documento de requisitos funcionales es algo mucho más sencillo. El documento funcional es una especie de contrato de lo que el desarrollador se compromete a hacer: en vez de comprometerse a hacer un software de calidad que resuelva problemas reales, el desarrollador se compromete <strong>sólo</strong> a implementar lo que está escrito en el funcional.</p>

<p>Si el producto no funciona bien, o no resuelve los problemas del cliente, el desarrollador se siente eximido de responsabilidad: "<em>Mi programa cumple el funcional -dice-, si querían otra cosa, tenían que haberlo dicho en el documento funcional</em>". La culpa no es mía, sino del cliente, que no ha sabido escribir un buen documento funcional.</p>

<p><strong>Los documentos funcionales son la excusa perfecta para hacer software chapucero y luego echarle la culpa al cliente.</strong></p>

  </div>
</article>


  
  
    <article class="entry" role="article">
  <div class="meta span1">
    <time class="date" datetime="" pubdate></time>
  </div>

  <div class="content span7">
    
      <h1 class="entry-title"><a href="/2010/06/04/como-distinguir-a-los-buenos-programadores/">Cómo distinguir a los buenos programadores</a></h1>
    

    <p><a href="http://codigocomestible.com/2010/05/14/los-buenos-programadores-son-un-chollo/">En una entrada anterior</a> hablaba de cómo los buenos desarrolladores son altamente rentables para las empresas. Aunque sea interesante, ese es un dato TBU, -<em>True But Useless</em>: Cierto pero inútil. De nada nos sirve saber que los buenos programadores son muy rentables si no podemos encontrarlos. El problema, como bien señala <a href="http://codigocomestible.com/2010/05/14/los-buenos-programadores-son-un-chollo/#comment-25">Jorge Eduardo Olaya</a>, es ¿cómo podemos distinguir a los buenos desarrolladores de los mediocres?</p>

<p>Es una pregunta complicada que no tiene una respuesta sencilla y no es extraño que muchas empresas se equivoquen con su respuesta. Los procesos que habitualmente siguen las grandes empresas para contratar gente son bastante penosos y están condenados al fracaso. Examinarlos nos puede servir, al menos, para descubrir como  <strong>no</strong> se distingue a los buenos desarrolladores.</p>

<p>En las grandes empresas las contrataciones suelen ser responsabilidad del departamento de recursos humanos, es decir gente especializada en contratar trabajadores pero que rara vez tiene conocimientos técnicos. Y eso es lo peor que se puede hacer para encontrar buenos programadores: dejar que <strong>sólo</strong> gente sin conocimientos técnicos evalúe a los aspirantes.</p>

<p>Alguien sin conocimientos técnicos tiene unos medios muy limitados para saber si un aspirante es adecuado para un puesto. Al final acaba limitándose al sencillo criterio de contar las bolitas del curriculum:</p>

<ul>
<li><em>Experto</em> en diseño de arquitecturas SOA mediante Servicios Web SOAP: 5 puntos</li></li>
<li><em>Experto</em> en diseño de arquitecturas JEE con EJBs -qué serán los EJBs piensan con razón en RRHH- 10 puntos.</li></li>
<li>Sun Certified Enterprise Architect for the Java EE Platform: 5 puntos</li></li>
<li>Etcétera.</li>
</ul>


<p>¿Y qué significa eso? Alguien con la cara suficientemente dura, puede "ser experto" en <em>cualquier</em> cosa.</p>

<p>Incluso, aunque el currículum no esté inflado, es muy difícil hacerse una idea del candidato sólo con leerlo. La experiencia y los títulos son indudablemente importantes, pero dicen poco de la dedicación y la capacidad de aprender nuevas cosas que, al paso al que evoluciona la informática, son las características más importantes que debe tener un buen desarrollador.</p>

<p><strong>La experiencia siempre es un grado</strong>, pero no es un criterio infalible: tampoco es raro ver a gente que lleva diez años programando sin haber aprovechado ese tiempo. <strong>Si alguien lleva diez años haciendo chapuzas, casi mejor que no tuviese esa experiencia, porque acaba tan acostumbrado a hacer chapuzas que no concibe que se pueda desarrollar software de otra manera</strong>.</p>

<p>Con los títulos pasa lo mismo: hay quien aprende en cada curso que hace, y hay otros muchos que sólo sacan de provecho un papel para enmarcar y dejar colgado de la pared, y una frase en el currículum.</p>

<p>Entonces, si todos estos métodos son tan deficientes, ¿como podemos distinguir a los buenos desarrolladores?</p>

<p>Para encontrar la respuesta pensemos en que, aunque alguien sin conocimientos técnicos no puede distinguir el código bien escrito del que es una chapuza, un buen desarrollador puede distinguirlos con facilidad. Hablando con un candidato puede hacerse rápidamente una idea del nivel de conocimientos del candidato, de si le interesa lo que hace y si realmente le gusta su trabajo. Si el candidato resuelve alguna tarea práctica es fácil evaluar su capacidad de enfrentarse a los problemas. Y si ha colaborado con proyectos Open Source <strong>muchísimo</strong> mejor: mirando sus contribuciones puedes hacerte una idea muy aproximada cómo trabaja ese programador.</p>

<p>Al final la respuesta al enigma de cómo se distingue a los buenos programadores es sencilla: <strong>los buenos programadores se distinguen entre sí.</strong></p>

  </div>
</article>


  

  <div class="span7 offset1">
    
      <a href="/page3">&larr; Más antiguos</a>
    
    |
    
      
      <a href="/">Más  recientes&rarr;</a>
      
    
  </div>


</div>

      </section>
      <aside id="sidebar" class="offset1 span3">
        <nav role="navigation">
  <ul class="main-navigation">
    <form action="http://google.es/search" method="get" class="form-search">
      <fieldset role="search">
        <input type="hidden" name="sitesearch" value="codigocomestible.com" />
        <input class="search" type="text" name="q" results="0" placeholder="buscar"/>
      </fieldset>
    </form>
    <li>
      <a href="/atom.xml">
        Feed RSS
      </a>
    </li>
    <li><a href="/archives">Archivo</a></li>
  </ul>
</nav>

<section>
  <h4>Artículos recientes</h4>
  <ul id="recent_posts">
    
    <li class="post">
      <a href="/2011/01/24/flujo-la-psicologia-de-la-experiencia-optima/">Flujo, la psicología de la experiencia óptima</a>
    </li>
    
    <li class="post">
      <a href="/2010/09/24/100-de-cobertura-del-codigo/">100% de cobertura del código</a>
    </li>
    
    <li class="post">
      <a href="/2010/07/07/software-con-opinion/">Software con opinión</a>
    </li>
    
    <li class="post">
      <a href="/2010/07/06/paralisis-por-analisis/">Parálisis por análisis</a>
    </li>
    
    <li class="post">
      <a href="/2010/07/06/fuerza-de-voluntad-recurso-finito/">La fuerza de voluntad es un recurso finito</a>
    </li>
    
  </ul>
</section>

<section>
  <h4>Dónde puedes encontrarme</h4>

  <ul>
    <li>
      <a href="mailto: afcapel at gmail dot com">
        <img src="/images/email_32.png" width="32" height="32"/>
        E-mail
      </a>
    </li>

   <li>
    <a href="http://twitter.com/afcapel">
      <img src="/images/twitter_32.png" width="32" height="32"/>
      Twitter
    </a>
   </li>

   <li>
    <a href="http://github.com/afcapel">
      <img src="/images/github_32.png" width="32" height="32"/>
      Github
    </a>
   </li>

  <li>
    <a href="https://plus.google.com/107729440292621307525?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32"/>
      Google+
    </a>
  </li>
</ul>
</section>
      </aside>
    </div>


    <footer role="contentinfo" id="main-footer">
      <p>Copyright &copy; 2013 - Alberto Fernández-Capel</p>
    </footer>
  </div>

  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-35983929-1']);
  _gaq.push(['_setDomainName', 'codigocomestible.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
